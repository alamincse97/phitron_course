অ্যারে জিনিসটা কি সেইটা জানার আগে আমরা জানার চেষ্টা করি, অ্যারে জিনিসটা আমরা কখন কি জন্যে ব্যবহার করবো। এইভাবে আমরা অ্যারে বুঝে যাব।
~~~~~~~~~~~~~~~~~~~~~~~~~~~
আমরা বিভিন্ন ডেটা টাইপ দিয়ে ভেরিয়েবল ডিক্লিয়ার করা শিখেছি। সেইগুলোতে আমরা একটি ভেরিয়েবলে একটি মান সংরক্ষণ করতে পারতাম, এখন যদি আমি তোমাকে বলে 100 টি মান ইনপুট নিয়ে সেইগুলোকে প্রিন্ট করে দেখাও। তাহলে তুমি কি 100 ভেরিয়েবল ডিক্লিয়ার করে করবা? এইটা তুমি অনেক কষ্ট করে লিখে করলা, কিন্তু আমি যদি তোমাকে বলি 10000 টি মান ইনপুট নাও, তখন কিন্তু তুমি আর একটা করে ভেরিয়েবল ডিক্লিয়ার করে করে 10000 বার কাজটা করতে পারবে নাহ।
ঠিক এইসময় আমরা অ্যারে নামক জিনিসটি ব্যাবহার করতে পারি।
অ্যারের মধ্যে তুমি অনেকগুলো মান একটার পর আরেকটা সারিবদ্ধভাবে রাখতে পারবা।
এমনে নরমাল ভেরিয়েবলকে তুমি একটা বাক্স মনে করতে পারো যেখানে শুধু একটা জিনিস রাখতে পারতা, কিন্তু অ্যারেকে তুমি এমন একটি বাক্স মনে করতে পারো যেখানে একসাথে অনেকগুলো জিনিস সিরিয়াল ভাবে রাখাতে পারবা। বাস্তব উদাহরণ বলতে গেলে একটা রঙের বাক্স মনে করতে পারো যেখানে অনেক গুলো রঙ পাশাপাশি রাখতে পারো।
~~~~~~~~~~~~~~~~~~~~~~~~~~~
এখন আসি অ্যারে ডিক্লিয়ার কিভাবে করবো। একটু দেখি,
data_type array_name[ array_size ];
প্রথমে, অ্যারেটা কোন ডেটা টাইপের হবে , তারপর অ্যারেটা নাম এবং তৃতীয় বন্ধনীর মধ্যে আছে আরেটার সাইজ যেইটার উপর নির্ভর করবে তুমি অ্যারেটাতে কয়টা মান রাখতে পারবা।

এখন দেখবো কিভাবে অ্যারেটাতে আমরা মানগুলো রাখবো।
প্রথমে একটা Integer ডেটা টাইপের অ্যারে ডিক্লিয়ার করি,
int marks[ 5 ];
এরপর, মান গুলো অ্যারের বিভিন্ন ইনডেক্সে রাখবো।
array_name[ index ] = value;
এখানে, যেই অ্যারেটাতে মান রাখবো সেইটার নাম লিখেবো , তারপর তৃতীয় বন্ধনীতে একটা ইনডেক্স দিবো অতএব অ্যারের কত নাম্বার পজিশনে মানটা রাখতে চাচ্ছি সেইটা লিখেছি। অ্যারের মান রাখার পজিশন শুরু হয় 0 থেকে, তাই তোমার অ্যারের সাইজ যদি 10 হয়, তাহলে তুমি 0 থেকে 9 নাম্বার পজিশন পর্যন্ত সেই অ্যারেটাতে মান রাখতে পারবে।
marks[ 0 ] = 10; // এইটাতে অ্যারের 0 নাম্বার পজিশনে 10 মানটি রাখা হয়েছে
marks[ 1 ] = 20;
marks[ 2 ] = 30;
marks[ 3 ] = 40;
marks[ 4 ] = 50;
এখন তুমি অ্যারেটার বিভিন্ন নাম্বার পজিশনের মান প্রিন্ট করে দেখাতে চাও।
তাহলে ,
printf("%d", marks[ 0 ] ); // আউটপুটে 10 দেখাবে
printf("%d", marks[ 4 ] ); // আউটপুটে 40 দেখাবে
~~~~~~~~~~~~~~~~~~~~~~~~~~~
অ্যারেটা ডিক্লিয়ার করার সময়ই ২ ভাবে মান রাখা যাই, এখন সেইটা দেখি চলো।
১ম ভাবে,
int marksFirst[ 5 ] = {10,20,30,40,50};
এই marksFirst অ্যারেটাও marks নামের অ্যারেটার মত ঠিক একইভাবে মান গুলো প্রিন্ট করতে পারবে।
এইখানে আমরা অ্যারেটা কত সাইজের হবে সেইটাও বলে দিয়েছি।
printf("%d", marksFirst[ 2 ]); // আউটপুটে 30 দেখাবে
২য় ভাবে,
int marksSecond[ ] = {10,20,30,40,50,60};
marksSecond অ্যারেটার সাইজ কত হবে সেইটা বলি নি। এইখানে অ্যারে সংরক্ষণ করে রাখা মানগুলো কয়টি সেইটা থেকে সাইজটি বের করে ফেলতে পারে। বেপার হচ্ছে, যতটা মান রাখা হয়েছে, ততটাই জায়গায় বানানো হয়েছে অ্যারেতে।
~~~~~~~~~~~~~~~~~~~~~~~~~~~
অ্যারেতে কিভাবে ইনপুট নেয়া যাই, সেইটা দেখি।
int marks[ 3 ];
scanf("%d %d %d",&marks[ 0 ], &marks[ 1 ], &marks[ 2 ]);
অ্যারেটার 0, 1, 2 পজিশনে 3টা মান ইনপুট নিলাম।
আমাদের যদি 10000 টা ইনপুট নিবে। তখনও কি আমরা এইভাবে ইনপুট নিবো?
-> না, আমরা উপরে দেখানো scanf এর মধ্যে অনেকগুলো একসাথে এইভাবে ইনপুট নিবো না।
আমরা একটি লুপ চালিয়ে অ্যারেটার প্রতিটি পজিশনের জন্য ইনপুট নিব। চল এইবার আমরা কোড দেখি।
int marks[ 5 ];
for(int i=0; i<5; i++) {
scanf("%d", &marks[ i ]); // 0 থেকে 4 পজিশন পর্যন্ত ইনপুট নিবে অ্যারেটার
}
কোড রান করার পর ইনপুটে যদি 10 20 30 40 50 দিলাম। তাহলে আমাদের অ্যারেটা হবে।
| 10 | 20 | 30 | 40 | 50 |
0 1 2 3 4 --> index of array
~~~~~~~~~~~~~~~~~~~~~~~~~~
এখন অ্যারেটা প্রিন্ট করে দেখি।
for(int i=0; i<n; i++) {
printf("Index %d: Value is %d.\n", i, marks[ i ]);
}
আউটপুট আসবেঃ
Index 0: Value is 10.
Index 1: Value is 20.
Index 2: Value is 30.
Index 3: Value is 40.
Index 4: Value is 50.
এখানে প্রথম %d তে index টা প্রিন্ট করেছি, ২য় %d তে অ্যারের সেই index এ থাকা মানটি প্রিন্ট করেছি।

